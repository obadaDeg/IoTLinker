"""
Device Management API Endpoints
CRUD operations for IoT devices
"""

from fastapi import APIRouter, HTTPException, Query, status
from typing import List, Optional
from uuid import UUID
from datetime import datetime, timedelta

from app.models import (
    DeviceCreate,
    DeviceUpdate,
    DeviceResponse,
    DeviceCredentials,
    DeviceListResponse,
    DeviceDataBatch,
    DeviceDataResponse,
    DeviceDataQuery,
    DeviceTypeResponse,
    DeviceStatus
)
from app.database import get_supabase, execute_query, execute_one, execute_write
from app.config import settings


router = APIRouter(prefix="/api/v1/devices", tags=["Devices"])


# =====================================================
# DEVICE CRUD ENDPOINTS
# =====================================================

@router.post("/", response_model=DeviceCredentials, status_code=status.HTTP_201_CREATED)
async def create_device(device: DeviceCreate):
    """
    Create a new IoT device

    Args:
        device: Device creation data

    Returns:
        Device credentials including device_key and device_secret
    """
    try:
        supabase = get_supabase()

        # Prepare device data
        device_data = {
            "tenant_id": str(device.tenant_id),
            "name": device.name,
            "description": device.description,
            "device_type_id": str(device.device_type_id) if device.device_type_id else None,
            "channel_id": str(device.channel_id) if device.channel_id else None,
            "location": device.location.model_dump() if device.location else None,
            "metadata": device.metadata or {},
            "configuration": device.configuration or {},
            "firmware_version": device.firmware_version,
            "status": "offline"  # New devices start as offline
        }

        # Insert device (device_key and device_secret are auto-generated by trigger)
        response = supabase.table("devices").insert(device_data).execute()

        if not response.data:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to create device"
            )

        created_device = response.data[0]

        # Return credentials
        return DeviceCredentials(
            device_id=created_device["id"],
            device_key=created_device["device_key"],
            device_secret=created_device["device_secret"],
            mqtt_endpoint="mqtt://localhost:1883"
        )

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating device: {str(e)}"
        )


@router.get("/", response_model=DeviceListResponse)
async def list_devices(
    tenant_id: UUID = Query(..., description="Tenant ID"),
    page: int = Query(1, ge=1, description="Page number"),
    page_size: int = Query(20, ge=1, le=100, description="Items per page"),
    status_filter: Optional[DeviceStatus] = Query(None, description="Filter by status"),
    search: Optional[str] = Query(None, description="Search by name"),
):
    """
    List all devices for a tenant with pagination

    Args:
        tenant_id: Tenant ID
        page: Page number
        page_size: Items per page
        status_filter: Optional status filter
        search: Optional search term

    Returns:
        Paginated list of devices
    """
    try:
        supabase = get_supabase()

        # Build query
        query = supabase.table("devices").select("*", count="exact").eq("tenant_id", str(tenant_id))

        # Apply filters
        if status_filter:
            query = query.eq("status", status_filter.value)

        if search:
            query = query.ilike("name", f"%{search}%")

        # Apply pagination
        start = (page - 1) * page_size
        end = start + page_size - 1
        query = query.range(start, end).order("created_at", desc=True)

        # Execute query
        response = query.execute()

        devices = [DeviceResponse(**device) for device in response.data]
        total = response.count if response.count else 0
        total_pages = (total + page_size - 1) // page_size

        return DeviceListResponse(
            devices=devices,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages
        )

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error listing devices: {str(e)}"
        )


@router.get("/{device_id}", response_model=DeviceResponse)
async def get_device(device_id: UUID):
    """
    Get a single device by ID

    Args:
        device_id: Device ID

    Returns:
        Device details
    """
    try:
        supabase = get_supabase()

        response = supabase.table("devices").select("*").eq("id", str(device_id)).execute()

        if not response.data:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Device {device_id} not found"
            )

        return DeviceResponse(**response.data[0])

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching device: {str(e)}"
        )


@router.put("/{device_id}", response_model=DeviceResponse)
async def update_device(device_id: UUID, device: DeviceUpdate):
    """
    Update a device

    Args:
        device_id: Device ID
        device: Updated device data

    Returns:
        Updated device
    """
    try:
        supabase = get_supabase()

        # Prepare update data (only include non-None fields)
        update_data = device.model_dump(exclude_unset=True, exclude_none=True)

        # Convert location to dict if present
        if "location" in update_data and update_data["location"]:
            update_data["location"] = update_data["location"]

        # Update device
        response = supabase.table("devices").update(update_data).eq("id", str(device_id)).execute()

        if not response.data:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Device {device_id} not found"
            )

        return DeviceResponse(**response.data[0])

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error updating device: {str(e)}"
        )


@router.delete("/{device_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_device(device_id: UUID):
    """
    Delete a device

    Args:
        device_id: Device ID
    """
    try:
        supabase = get_supabase()

        response = supabase.table("devices").delete().eq("id", str(device_id)).execute()

        if not response.data:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Device {device_id} not found"
            )

        return None

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error deleting device: {str(e)}"
        )


# =====================================================
# DEVICE DATA ENDPOINTS
# =====================================================

@router.post("/{device_id}/data", status_code=status.HTTP_201_CREATED)
async def ingest_device_data(device_id: UUID, data_batch: DeviceDataBatch):
    """
    Ingest device sensor data

    Args:
        device_id: Device ID
        data_batch: Batch of sensor data points

    Returns:
        Success message
    """
    try:
        # Verify device exists and authenticate with device_key
        supabase = get_supabase()

        device_response = supabase.table("devices").select("id, tenant_id, device_key").eq("id", str(device_id)).execute()

        if not device_response.data:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Device {device_id} not found"
            )

        device = device_response.data[0]

        # Authenticate device
        if device["device_key"] != data_batch.device_key:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid device credentials"
            )

        # Prepare data points
        timestamp = data_batch.timestamp or datetime.utcnow()
        data_points = []

        for point in data_batch.data:
            data_points.append({
                "time": timestamp.isoformat(),
                "device_id": str(device_id),
                "tenant_id": device["tenant_id"],
                "metric_name": point.metric_name,
                "value": point.value,
                "unit": point.unit,
                "metadata": point.metadata or {},
                "quality_score": point.quality_score or 100
            })

        # Insert data points
        response = supabase.table("device_data").insert(data_points).execute()

        # Update device last_seen
        supabase.table("devices").update({"last_seen": timestamp.isoformat()}).eq("id", str(device_id)).execute()

        return {
            "message": "Data ingested successfully",
            "device_id": str(device_id),
            "data_points": len(data_points),
            "timestamp": timestamp.isoformat()
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error ingesting data: {str(e)}"
        )


@router.get("/{device_id}/data", response_model=List[DeviceDataResponse])
async def get_device_data(
    device_id: UUID,
    metric_name: Optional[str] = Query(None, description="Filter by metric name"),
    start_time: Optional[datetime] = Query(None, description="Start time (ISO 8601)"),
    end_time: Optional[datetime] = Query(None, description="End time (ISO 8601)"),
    limit: int = Query(100, ge=1, le=10000, description="Maximum number of data points")
):
    """
    Get device sensor data

    Args:
        device_id: Device ID
        metric_name: Optional metric filter
        start_time: Optional start time
        end_time: Optional end time
        limit: Maximum number of data points

    Returns:
        List of sensor data points
    """
    try:
        supabase = get_supabase()

        # Build query
        query = supabase.table("device_data").select("*").eq("device_id", str(device_id))

        # Apply filters
        if metric_name:
            query = query.eq("metric_name", metric_name)

        if start_time:
            query = query.gte("time", start_time.isoformat())

        if end_time:
            query = query.lte("time", end_time.isoformat())

        # Order and limit
        query = query.order("time", desc=True).limit(limit)

        # Execute
        response = query.execute()

        return [DeviceDataResponse(**data) for data in response.data]

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching device data: {str(e)}"
        )


# =====================================================
# DEVICE TYPES ENDPOINTS
# =====================================================

@router.get("/types/list", response_model=List[DeviceTypeResponse])
async def list_device_types():
    """
    List all available device types

    Returns:
        List of device types
    """
    try:
        supabase = get_supabase()

        response = supabase.table("device_types").select("*").execute()

        return [DeviceTypeResponse(**dt) for dt in response.data]

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching device types: {str(e)}"
        )
